const { Innertube } = require('youtubei.js');
const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');

async function extractVideoId(url) {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /^([a-zA-Z0-9_-]{11})$/
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  return null;
}

async function scrapeVideo(videoUrl) {
  const youtube = await Innertube.create();
  const videoId = await extractVideoId(videoUrl);

  if (!videoId) {
    throw new Error(`Invalid YouTube URL: ${videoUrl}`);
  }

  console.log(`Processing video: ${videoId}`);

  const info = await youtube.getInfo(videoId);

  const videoData = {
    id: videoId,
    title: info.basic_info.title,
    author: info.basic_info.author,
    duration: info.basic_info.duration,
    view_count: info.basic_info.view_count,
    description: info.basic_info.short_description,
    upload_date: info.primary_info?.published?.text || null,
    url: videoUrl,
    scraped_at: new Date().toISOString()
  };

  const videoDir = path.join('data', videoId);
  await fs.mkdir(videoDir, { recursive: true });

  await fs.writeFile(
    path.join(videoDir, 'metadata.json'),
    JSON.stringify(videoData, null, 2)
  );

  const captionTracks = info.captions?.caption_tracks || [];
  console.log(`Found ${captionTracks.length} caption tracks`);

  for (const track of captionTracks) {
    const languageCode = track.language_code;
    const isAutoGenerated = track.kind === 'asr';
    const prefix = isAutoGenerated ? 'auto_' : '';

    console.log(`Downloading ${languageCode} captions (${isAutoGenerated ? 'auto-generated' : 'manual'})`);

    try {
      const transcript = await youtube.getTranscript(videoId, {
        lang: languageCode
      });

      if (transcript && transcript.content) {
        const srtContent = convertToSRT(transcript.content.body.initial_segments);
        await fs.writeFile(
          path.join(videoDir, `${prefix}${languageCode}.srt`),
          srtContent
        );

        const txtContent = transcript.content.body.initial_segments
          .map(segment => segment.snippet.text)
          .join(' ');
        await fs.writeFile(
          path.join(videoDir, `${prefix}${languageCode}.txt`),
          txtContent
        );
      }
    } catch (error) {
      console.error(`Failed to download ${languageCode} captions:`, error.message);
    }
  }

  return videoData;
}

function convertToSRT(segments) {
  return segments.map((segment, index) => {
    const startTime = formatTime(segment.start_ms);
    const endTime = formatTime(segment.end_ms);
    const text = segment.snippet.text;

    return `${index + 1}\n${startTime} --> ${endTime}\n${text}\n`;
  }).join('\n');
}

function formatTime(ms) {
  const totalSeconds = Math.floor(ms / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;
  const milliseconds = ms % 1000;

  return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')},${String(milliseconds).padStart(3, '0')}`;
}

async function getUnprocessedUrls() {
  if (process.env.GITHUB_ACTIONS) {
    const github = require('@actions/github');
    const core = require('@actions/core');

    const token = process.env.GITHUB_TOKEN;
    const octokit = github.getOctokit(token);

    const { data: issues } = await octokit.rest.issues.listForRepo({
      owner: github.context.repo.owner,
      repo: github.context.repo.repo,
      state: 'open',
      labels: 'youtube-url'
    });

    const urls = [];
    const issuesToClose = [];

    for (const issue of issues) {
      const urlMatch = issue.body.match(/(https?:\/\/(www\.)?(youtube\.com|youtu\.be)\/[^\s]+)/);
      if (urlMatch) {
        urls.push(urlMatch[0]);
        issuesToClose.push(issue.number);
      }
    }

    return { urls, issuesToClose };
  } else {
    const urlsFile = 'urls.txt';
    try {
      const content = await fs.readFile(urlsFile, 'utf-8');
      const urls = content.split('\n').filter(url => url.trim());
      return { urls, issuesToClose: [] };
    } catch (error) {
      console.log('No urls.txt file found, using example URL');
      return { urls: [], issuesToClose: [] };
    }
  }
}

async function closeIssues(issueNumbers) {
  if (!process.env.GITHUB_ACTIONS || issueNumbers.length === 0) return;

  const github = require('@actions/github');
  const token = process.env.GITHUB_TOKEN;
  const octokit = github.getOctokit(token);

  for (const issueNumber of issueNumbers) {
    await octokit.rest.issues.update({
      owner: github.context.repo.owner,
      repo: github.context.repo.repo,
      issue_number: issueNumber,
      state: 'closed'
    });
    console.log(`Closed issue #${issueNumber}`);
  }
}

async function commitChanges(videoIds) {
  if (!process.env.GITHUB_ACTIONS) return;

  try {
    execSync('git config user.name "GitHub Actions Bot"');
    execSync('git config user.email "actions@github.com"');
    execSync('git add data/');

    const message = `Add captions for videos: ${videoIds.join(', ')}`;
    execSync(`git commit -m "${message}"`);
    execSync('git push');

    console.log('Changes committed and pushed');
  } catch (error) {
    console.error('Failed to commit changes:', error.message);
  }
}

async function main() {
  try {
    const { urls, issuesToClose } = await getUnprocessedUrls();

    if (urls.length === 0) {
      console.log('No URLs to process');
      return;
    }

    const processedVideoIds = [];

    for (const url of urls) {
      try {
        const videoData = await scrapeVideo(url);
        processedVideoIds.push(videoData.id);
        console.log(`Successfully processed: ${videoData.title}`);
      } catch (error) {
        console.error(`Failed to process ${url}:`, error.message);
      }
    }

    if (processedVideoIds.length > 0) {
      await commitChanges(processedVideoIds);
      await closeIssues(issuesToClose);
    }

  } catch (error) {
    console.error('Fatal error:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = { scrapeVideo, extractVideoId };